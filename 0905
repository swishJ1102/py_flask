为了支持你提到的规则（包括给类添加注解、字段上添加注解、修改方法体内容等）以及 XML 解析的结构，我们需要修改 `JavaFileModifier` 和 `BatchProcessor` 类来实现以下功能：

1. **JavaFileModifier**：
   - 支持根据 `Rule` 添加类注解、导入语句。
   - 支持 `MethodRule`，可以处理方法的增删改操作。
   - 处理字段级别的注解增加。
   
2. **BatchProcessor**：
   - 负责遍历项目中的文件夹，找到符合规则的 Java 文件。
   - 对每个文件应用所有的规则，保证不会覆盖上一次的修改。
   
### 修改后的 `JavaFileModifier`

```java
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.ImportDeclaration;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.Optional;

public class JavaFileModifier {

    // 解析器实例化
    private JavaParser javaParser = new JavaParser();

    public void modifyFile(File file, List<Rule> rules) throws IOException {
        // 读取并解析文件
        CompilationUnit cu = javaParser.parse(file).getResult().orElse(null);
        if (cu == null) {
            System.out.println("Error parsing file: " + file.getName());
            return;
        }

        // 对每个规则进行处理
        for (Rule rule : rules) {
            // 文件匹配模式
            if (file.getName().matches(rule.getFilePattern())) {

                // 处理类注解和导入
                Optional<ClassOrInterfaceDeclaration> classDeclaration = cu.findFirst(ClassOrInterfaceDeclaration.class);
                if (classDeclaration.isPresent()) {
                    ClassOrInterfaceDeclaration clazz = classDeclaration.get();
                    
                    // 添加类注解
                    if (rule.getClassAnnotation() != null) {
                        clazz.addAnnotation(rule.getClassAnnotation());
                    }

                    // 添加导入
                    for (String importStr : rule.getImports()) {
                        cu.addImport(importStr);
                    }
                }

                // 处理方法增删改
                for (MethodRule methodRule : rule.getMethods()) {
                    modifyMethod(cu, methodRule);
                }
            }
        }

        // 将修改后的代码保存到文件
        Files.write(Paths.get(file.getAbsolutePath()), cu.toString().getBytes());
    }

    // 修改方法体内容
    private void modifyMethod(CompilationUnit cu, MethodRule methodRule) {
        List<MethodDeclaration> methods = cu.findAll(MethodDeclaration.class, m -> m.getNameAsString().equals(methodRule.getName()));

        for (MethodDeclaration method : methods) {
            if (methodRule.getAction().equals("modify")) {
                // 删除指定的行
                for (String deleteLine : methodRule.getDeleteLines()) {
                    method.getBody().ifPresent(body -> {
                        body.getStatements().removeIf(statement -> statement.toString().contains(deleteLine));
                    });
                }

                // 在某行后添加新内容
                if (methodRule.getAfterLine() != null) {
                    method.getBody().ifPresent(body -> {
                        NodeList<Statement> statements = body.getStatements();
                        for (int i = 0; i < statements.size(); i++) {
                            if (statements.get(i).toString().contains(methodRule.getAfterLine())) {
                                for (String addLine : methodRule.getAddLines()) {
                                    Statement newStatement = javaParser.parseStatement(addLine).getResult().orElse(null);
                                    if (newStatement != null) {
                                        statements.add(i + 1, newStatement);
                                    }
                                }
                            }
                        }
                    });
                }
            }
            // 处理添加方法
            else if (methodRule.getAction().equals("add")) {
                for (String addLine : methodRule.getAddLines()) {
                    method.getBody().ifPresent(body -> {
                        Statement newStatement = javaParser.parseStatement(addLine).getResult().orElse(null);
                        if (newStatement != null) {
                            body.addStatement(newStatement);
                        }
                    });
                }
            }
            // 处理删除方法
            else if (methodRule.getAction().equals("remove")) {
                method.remove();
            }
        }
    }

    // 处理字段注解添加
    public void addFieldAnnotation(CompilationUnit cu, String fieldName, String annotation, String importStr) {
        List<FieldDeclaration> fields = cu.findAll(FieldDeclaration.class);

        for (FieldDeclaration field : fields) {
            if (field.getVariables().stream().anyMatch(v -> v.getNameAsString().equals(fieldName))) {
                field.addAnnotation(annotation);
                cu.addImport(importStr);
            }
        }
    }
}
```

### 修改后的 `BatchProcessor`

`BatchProcessor` 负责遍历项目中的文件夹，并调用 `JavaFileModifier` 来应用规则。

```java
import java.io.File;
import java.util.List;

public class BatchProcessor {
    private List<Rule> rules;
    private JavaFileModifier fileModifier;

    public BatchProcessor(List<Rule> rules) {
        this.rules = rules;
        this.fileModifier = new JavaFileModifier();
    }

    public void processFiles(File directory) throws Exception {
        // 递归遍历目录中的所有文件
        File[] files = directory.listFiles();
        if (files == null) {
            return;
        }

        for (File file : files) {
            if (file.isDirectory()) {
                processFiles(file); // 递归处理子目录
            } else if (file.getName().endsWith(".java")) {
                // 修改 Java 文件
                fileModifier.modifyFile(file, rules);
            }
        }
    }
}
```

### 逻辑解析

1. **`JavaFileModifier`**：
   - 解析文件后，检查是否匹配某条规则。
   - **类注解**：根据 `Rule` 中的 `classAnnotation` 添加类注解，并同时添加相应的导入语句。
   - **方法处理**：根据 `MethodRule` 的增删改规则处理方法内容，包括删除指定行、添加新行以及删除整个方法。
   - **字段注解**：提供了 `addFieldAnnotation` 方法来为指定字段添加注解并导入相应的类。

2. **`BatchProcessor`**：
   - 遍历项目文件夹，找到所有 Java 文件。
   - 每个 Java 文件会应用 `JavaFileModifier` 的规则处理。
   - 支持递归地处理子目录中的文件。

### 特殊情况处理

如果你有特殊的逻辑（如动态生成方法体内容、从外部配置文件读取值等），你可以在 `modifyMethod` 方法中进一步扩展 `MethodRule`，通过判断 `hasDynamicContent` 来动态添加内容。

```java
if (methodRule.isHasDynamicContent()) {
    // 根据配置文件或其他动态内容生成方法体
    String dynamicContent = getDynamicContentFromConfig();
    Statement newStatement = javaParser.parseStatement(dynamicContent).getResult().orElse(null);
    if (newStatement != null) {
        method.getBody().ifPresent(body -> body.addStatement(newStatement));
    }
}
```

### 总结

通过 `JavaFileModifier` 和 `BatchProcessor` 的修改，我们可以按照规则批量处理 Java 文件，包括添加类和字段注解、修改方法体内容、以及动态生成代码。你可以根据项目需求继续扩展和优化这两个类，以处理更多复杂的修改场景。

是的，既然我们在 `Rule` 类中新增了更详细的规则内容，包括对方法的修改（`MethodRule`），那么在 `XMLRuleParser` 解析时，也要做相应的调整，以支持这些新加入的规则字段。

### `XMLRuleParser` 修改计划

1. **解析 `MethodRule`**：支持从 XML 中读取方法修改规则（如增加、删除行的操作）。
2. **解析类注解和导入语句**：支持从 XML 读取类注解和导入的配置。
3. **解析文件匹配模式**：根据文件名的正则表达式匹配特定文件。

### 修改后的 XML 配置示例

首先，让我们看一个修改后的 XML 配置示例，它支持我们新的 `Rule` 和 `MethodRule` 结构：

```xml
<rules>
    <rule>
        <filePattern>.*Controller\.java$</filePattern>
        <classAnnotation>Controller</classAnnotation>
        <imports>
            <import>org.springframework.stereotype.Controller</import>
        </imports>
        <methods>
            <method>
                <name>findForward</name>
                <action>modify</action>
                <deleteLines>
                    <line>System.out.println("Old Line");</line>
                </deleteLines>
                <addLines>
                    <line>System.out.println("New Line");</line>
                </addLines>
                <afterLine>return "success";</afterLine>
            </method>
        </methods>
    </rule>

    <rule>
        <filePattern>.*Service\.java$</filePattern>
        <classAnnotation>Service</classAnnotation>
        <imports>
            <import>org.springframework.stereotype.Service</import>
        </imports>
        <methods>
            <method>
                <name>myMethod</name>
                <action>add</action>
                <addLines>
                    <line>System.out.println("Newly added line");</line>
                </addLines>
            </method>
        </methods>
    </rule>
</rules>
```

### 修改后的 `XMLRuleParser`

接下来是修改后的 `XMLRuleParser`，该解析器能正确解析上面提到的 XML 结构，并返回 `Rule` 和 `MethodRule` 对象。

```java
import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class XMLRuleParser {

    public List<Rule> parseRules(String xmlFilePath) throws Exception {
        List<Rule> rules = new ArrayList<>();
        File xmlFile = new File(xmlFilePath);
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(xmlFile);
        doc.getDocumentElement().normalize();

        NodeList ruleNodes = doc.getElementsByTagName("rule");

        for (int i = 0; i < ruleNodes.getLength(); i++) {
            Node ruleNode = ruleNodes.item(i);

            if (ruleNode.getNodeType() == Node.ELEMENT_NODE) {
                Element ruleElement = (Element) ruleNode;

                // 解析 filePattern
                String filePattern = ruleElement.getElementsByTagName("filePattern").item(0).getTextContent();

                // 解析 classAnnotation
                String classAnnotation = ruleElement.getElementsByTagName("classAnnotation").item(0).getTextContent();

                // 解析 imports
                List<String> imports = new ArrayList<>();
                NodeList importNodes = ruleElement.getElementsByTagName("import");
                for (int j = 0; j < importNodes.getLength(); j++) {
                    imports.add(importNodes.item(j).getTextContent());
                }

                // 解析 methods
                List<MethodRule> methods = new ArrayList<>();
                NodeList methodNodes = ruleElement.getElementsByTagName("method");

                for (int j = 0; j < methodNodes.getLength(); j++) {
                    Element methodElement = (Element) methodNodes.item(j);

                    String methodName = methodElement.getElementsByTagName("name").item(0).getTextContent();
                    String action = methodElement.getElementsByTagName("action").item(0).getTextContent();

                    // 解析 deleteLines
                    List<String> deleteLines = new ArrayList<>();
                    NodeList deleteLineNodes = methodElement.getElementsByTagName("deleteLines");
                    if (deleteLineNodes.getLength() > 0) {
                        NodeList lines = ((Element) deleteLineNodes.item(0)).getElementsByTagName("line");
                        for (int k = 0; k < lines.getLength(); k++) {
                            deleteLines.add(lines.item(k).getTextContent());
                        }
                    }

                    // 解析 addLines
                    List<String> addLines = new ArrayList<>();
                    NodeList addLineNodes = methodElement.getElementsByTagName("addLines");
                    if (addLineNodes.getLength() > 0) {
                        NodeList lines = ((Element) addLineNodes.item(0)).getElementsByTagName("line");
                        for (int k = 0; k < lines.getLength(); k++) {
                            addLines.add(lines.item(k).getTextContent());
                        }
                    }

                    // 解析 afterLine
                    String afterLine = null;
                    NodeList afterLineNodes = methodElement.getElementsByTagName("afterLine");
                    if (afterLineNodes.getLength() > 0) {
                        afterLine = afterLineNodes.item(0).getTextContent();
                    }

                    // 创建 MethodRule 对象
                    MethodRule methodRule = new MethodRule(
                            methodName, action, deleteLines, addLines, afterLine, false
                    );
                    methods.add(methodRule);
                }

                // 创建 Rule 对象
                Rule rule = new Rule(filePattern, classAnnotation, imports, methods);
                rules.add(rule);
            }
        }

        return rules;
    }
}
```

### 解析过程说明

1. **解析文件模式**：通过 `filePattern` 匹配要修改的 Java 文件。
2. **解析类注解**：从 `classAnnotation` 标签中获取需要加在类上的注解。
3. **解析导入语句**：从 `imports` 标签中读取需要导入的包。
4. **解析方法规则**：从 `methods` 标签下读取每个方法的修改规则，包括方法名、要执行的操作（增、删、改）、需要删除的行、需要添加的行、以及指定在哪行后添加新内容。
5. **解析条件行**：使用 `afterLine` 来控制在某行之后插入新代码。

### 扩展解析

如果你有更多复杂的规则，比如：
- **动态内容**：可以扩展 `MethodRule` 来支持从其他配置文件或动态生成的内容。
- **复杂匹配逻辑**：在 `XMLRuleParser` 中添加额外的条件逻辑。

### 最终使用

将解析得到的规则传递给 `JavaFileModifier`，然后在批处理程序中应用这些规则。例如：

```java
public class Main {
    public static void main(String[] args) {
        try {
            XMLRuleParser parser = new XMLRuleParser();
            List<Rule> rules = parser.parseRules("path_to_rules.xml");

            // 假设你已经定义了 MethodContent 的逻辑并初始化了 methodContentMap
            Map<String, MethodContent> methodContentMap = new HashMap<>();

            BatchProcessor processor = new BatchProcessor(rules, methodContentMap);
            processor.processFiles(new File("path_to_java_project"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 总结

通过对 `XMLRuleParser` 的修改，现在可以支持更加灵活、详细的增删改规则。`XMLRuleParser` 会读取 XML 配置，并生成相应的 `Rule` 和 `MethodRule` 对象，最后应用于 Java 文件的批量修改任务中。

好的，下面是对 `Rule` 类的补全，包括了文件模式、类注解、导入、方法的增删改规则等。

### `Rule` 类的完整实现

```java
import java.util.List;

public class Rule {
    private String filePattern;  // 用于匹配文件的正则表达式
    private String classAnnotation;  // 类上需要添加的注解
    private List<String> imports;  // 需要添加的 import 语句
    private List<MethodRule> methods;  // 需要处理的方法规则

    // 构造函数
    public Rule(String filePattern, String classAnnotation, List<String> imports, List<MethodRule> methods) {
        this.filePattern = filePattern;
        this.classAnnotation = classAnnotation;
        this.imports = imports;
        this.methods = methods;
    }

    // Getters and Setters
    public String getFilePattern() {
        return filePattern;
    }

    public void setFilePattern(String filePattern) {
        this.filePattern = filePattern;
    }

    public String getClassAnnotation() {
        return classAnnotation;
    }

    public void setClassAnnotation(String classAnnotation) {
        this.classAnnotation = classAnnotation;
    }

    public List<String> getImports() {
        return imports;
    }

    public void setImports(List<String> imports) {
        this.imports = imports;
    }

    public List<MethodRule> getMethods() {
        return methods;
    }

    public void setMethods(List<MethodRule> methods) {
        this.methods = methods;
    }
}
```

### `MethodRule` 类

`MethodRule` 用于描述方法修改的详细规则，例如方法的名称、删除行、增加行，以及是否需要动态内容。

```java
import java.util.List;

public class MethodRule {
    private String name;  // 方法名
    private String action;  // 对方法执行的操作，如"add", "modify", "remove"
    private List<String> deleteLines;  // 需要删除的行
    private List<String> addLines;  // 需要添加的行
    private String afterLine;  // 指定在某行之后添加新内容
    private boolean hasDynamicContent;  // 是否需要动态内容（例如从配置中读取）

    // 构造函数
    public MethodRule(String name, String action, List<String> deleteLines, List<String> addLines, String afterLine, boolean hasDynamicContent) {
        this.name = name;
        this.action = action;
        this.deleteLines = deleteLines;
        this.addLines = addLines;
        this.afterLine = afterLine;
        this.hasDynamicContent = hasDynamicContent;
    }

    // Getters and Setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public List<String> getDeleteLines() {
        return deleteLines;
    }

    public void setDeleteLines(List<String> deleteLines) {
        this.deleteLines = deleteLines;
    }

    public List<String> getAddLines() {
        return addLines;
    }

    public void setAddLines(List<String> addLines) {
        this.addLines = addLines;
    }

    public String getAfterLine() {
        return afterLine;
    }

    public void setAfterLine(String afterLine) {
        this.afterLine = afterLine;
    }

    public boolean isHasDynamicContent() {
        return hasDynamicContent;
    }

    public void setHasDynamicContent(boolean hasDynamicContent) {
        this.hasDynamicContent = hasDynamicContent;
    }
}
```

### 使用示例

下面是一个基于 `Rule` 类和 `MethodRule` 类的示例配置：

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        // 创建方法修改规则
        MethodRule methodRule = new MethodRule(
            "exampleMethod",   // 方法名
            "modify",          // 操作类型
            Arrays.asList("System.out.println(\"Old Line\");"),  // 要删除的行
            Arrays.asList("System.out.println(\"New Line\");"),  // 要添加的行
            null,              // 在某一行之后添加
            false              // 是否需要动态内容
        );

        // 创建一个文件规则
        Rule rule = new Rule(
            ".*Controller\\.java$",  // 文件匹配模式，所有以Controller结尾的类
            "Controller",            // 需要添加的类注解
            Arrays.asList("org.springframework.stereotype.Controller"),  // 需要添加的import
            Arrays.asList(methodRule)  // 方法修改规则
        );

        // 使用 JavaFileModifier 进行修改
        JavaFileModifier modifier = new JavaFileModifier(null);
        try {
            modifier.modifyFiles(new File("path_to_java_file"), Arrays.asList(rule));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 扩展

- **更多规则**：如果你有多种规则，比如增加 `@Service` 或 `@Component` 注解，可以在配置中添加多个 `Rule` 对象，每个对象负责不同的规则。
- **特殊逻辑处理**：通过在 `MethodRule` 中扩展更多字段或标志位，来处理特殊情况，如动态内容生成、特定的匹配条件等。

### 逻辑解析过程

1. **文件匹配**：`filePattern` 用于筛选要修改的文件，比如所有以 `Controller` 结尾的类。
2. **注解添加**：`classAnnotation` 和 `imports` 用于定义类上需要增加的注解以及相应的导入语句。
3. **方法处理**：`methods` 列表中包含一组 `MethodRule`，每个 `MethodRule` 用于描述如何修改类中的方法，比如删除某些行或添加某些行。

通过这种结构，你可以灵活地配置不同的规则，来实现对 Java 项目中不同文件的批量修改。

要进一步完善配置文件，以支持对特定类型的多个文件进行批量操作，我们可以将规则细化为多个层次。新的 XML 配置文件将包含对类的注解添加、导入语句的更新、方法体的修改、删除和增加行内容等操作。

### 1. **完善后的 XML 配置文件设计**

下面是一个更复杂的 XML 配置文件示例，它支持对特定类型的多个文件执行批量操作。

#### 完善后的 XML 配置文件（`rules.xml`）

```xml
<rules>
    <!-- 对特定类型的文件（例如以 Service 结尾的类）添加注解和导入语句 -->
    <rule>
        <filePattern pattern=".*Service.java">
            <classAnnotation annotation="org.springframework.stereotype.Service"/>
            <import package="org.springframework.stereotype.Service"/>
        </filePattern>
    </rule>

    <!-- 更新导入语句，添加或替换旧的导入 -->
    <rule>
        <filePattern pattern=".*Service.java">
            <import package="org.springframework.beans.factory.annotation.Autowired"/>
            <import package="java.util.Optional" action="replace" oldPackage="java.util.List"/>
        </filePattern>
    </rule>

    <!-- 修改特定方法体，删除、增加或替换行内容 -->
    <rule>
        <filePattern pattern=".*Service.java">
            <method name="findAll" action="modify">
                <delete line="return this.repository.findAll();"/>
                <add line="List<MyEntity> entities = this.repository.findAll();" after="List<MyEntity> result = this.repository.findAll();"/>
            </method>
        </filePattern>
    </rule>
    
    <!-- 删除某个方法体 -->
    <rule>
        <filePattern pattern=".*Service.java">
            <method name="deleteMethod" action="remove"/>
        </filePattern>
    </rule>
</rules>
```

### 2. **解析器和规则结构更新**

为了支持更复杂的配置文件，我们需要扩展之前的解析器和规则结构，使其能够处理新的规则类型。

#### 更新后的 `Rule` 类

```java
import java.util.ArrayList;
import java.util.List;

public class Rule {
    private String filePattern;
    private String classAnnotation;
    private List<String> imports = new ArrayList<>();
    private List<MethodRule> methods = new ArrayList<>();

    // Getters and setters

    public void addImport(String importPackage) {
        this.imports.add(importPackage);
    }

    public void addMethodRule(MethodRule methodRule) {
        this.methods.add(methodRule);
    }
}

class MethodRule {
    private String name;
    private String action; // modify, remove
    private List<String> addLines = new ArrayList<>();
    private List<String> deleteLines = new ArrayList<>();
    private String afterLine;

    // Getters and setters

    public void addAddLine(String line) {
        this.addLines.add(line);
    }

    public void addDeleteLine(String line) {
        this.deleteLines.add(line);
    }
}
```

#### 更新后的 `XMLRuleParser` 类

```java
import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class XMLRuleParser {

    public List<Rule> parseRules(String filePath) {
        List<Rule> rules = new ArrayList<>();
        try {
            File file = new File(filePath);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(file);

            doc.getDocumentElement().normalize();

            NodeList ruleList = doc.getElementsByTagName("rule");

            for (int i = 0; i < ruleList.getLength(); i++) {
                Node node = ruleList.item(i);
                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    Element element = (Element) node;
                    Rule rule = new Rule();

                    NodeList childNodes = element.getChildNodes();
                    for (int j = 0; j < childNodes.getLength(); j++) {
                        Node childNode = childNodes.item(j);
                        if (childNode.getNodeType() == Node.ELEMENT_NODE) {
                            Element childElement = (Element) childNode;
                            String tagName = childElement.getTagName();

                            if (tagName.equals("filePattern")) {
                                rule.setFilePattern(childElement.getAttribute("pattern"));
                                
                                NodeList filePatternChildren = childElement.getChildNodes();
                                for (int k = 0; k < filePatternChildren.getLength(); k++) {
                                    Node filePatternChild = filePatternChildren.item(k);
                                    if (filePatternChild.getNodeType() == Node.ELEMENT_NODE) {
                                        Element fpChildElement = (Element) filePatternChild;
                                        String fpChildTagName = fpChildElement.getTagName();

                                        if (fpChildTagName.equals("classAnnotation")) {
                                            rule.setClassAnnotation(fpChildElement.getAttribute("annotation"));
                                        }

                                        if (fpChildTagName.equals("import")) {
                                            String importPackage = fpChildElement.getAttribute("package");
                                            String action = fpChildElement.getAttribute("action");
                                            String oldPackage = fpChildElement.getAttribute("oldPackage");
                                            if ("replace".equals(action) && oldPackage != null) {
                                                // Replace old import with the new one
                                                rule.getImports().remove(oldPackage);
                                            }
                                            rule.addImport(importPackage);
                                        }

                                        if (fpChildTagName.equals("method")) {
                                            MethodRule methodRule = new MethodRule();
                                            methodRule.setName(fpChildElement.getAttribute("name"));
                                            methodRule.setAction(fpChildElement.getAttribute("action"));

                                            NodeList methodChildren = fpChildElement.getChildNodes();
                                            for (int l = 0; l < methodChildren.getLength(); l++) {
                                                Node methodChild = methodChildren.item(l);
                                                if (methodChild.getNodeType() == Node.ELEMENT_NODE) {
                                                    Element methodChildElement = (Element) methodChild;
                                                    String methodChildTagName = methodChildElement.getTagName();

                                                    if (methodChildTagName.equals("delete")) {
                                                        methodRule.addDeleteLine(methodChildElement.getAttribute("line"));
                                                    }
                                                    if (methodChildTagName.equals("add")) {
                                                        methodRule.addAddLine(methodChildElement.getAttribute("line"));
                                                        methodRule.setAfterLine(methodChildElement.getAttribute("after"));
                                                    }
                                                }
                                            }
                                            rule.addMethodRule(methodRule);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    rules.add(rule);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return rules;
    }
}
```

### 3. **Java 文件修改器更新**

我们需要更新 `JavaFileModifier`，使其能够处理导入语句的替换、方法体的行删除和添加。

#### 更新后的 `JavaFileModifier` 类

```java
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.Statement;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.util.List;

public class JavaFileModifier {

    public void modifyFiles(File file, List<Rule> rules) throws Exception {
        FileInputStream in = new FileInputStream(file);
        CompilationUnit cu = new JavaParser().parse(in).getResult().get();
        in.close();

        for (Rule rule : rules) {
            if (rule.getFilePattern() != null && file.getName().matches(rule.getFilePattern())) {
                if (rule.getClassAnnotation() != null) {
                    modifyClass(cu, rule);
                }
                if (!rule.getImports().isEmpty()) {
                    modifyImports(cu, rule);
                }
                if (!rule.getMethods().isEmpty()) {
                    modifyMethods(cu, rule);
                }
            }
        }

        try (FileWriter fileWriter = new FileWriter(file)) {
            fileWriter.write(cu.toString());
        }
    }

    private void modifyClass(CompilationUnit cu, Rule rule) {
        cu.findAll(ClassOrInterfaceDeclaration.class).forEach(c -> {
            c.addAnnotation(new MarkerAnnotationExpr(rule.getClassAnnotation()));
        });
    }

    private void modifyImports(CompilationUnit cu, Rule rule) {
        for (String importPackage : rule.getImports()) {
            if (!cu.getImports().stream().anyMatch(i -> i.getNameAsString().equals(importPackage))) {
                cu.addImport(importPackage);
            }
        }
    }

    private void modifyMethods(CompilationUnit cu, Rule rule) {
        for (MethodRule methodRule : rule.getMethods()) {
            cu.findAll(MethodDeclaration.class).forEach(m -> {
                if (m.getNameAsString().equals(methodRule.getName())) {
                    if ("remove".equals(methodRule.getAction())) {
                        m.remove();
                    } else if ("modify".equals(methodRule.getAction())) {
                        BlockStmt body = m.getBody().orElse(null);
                        if (body != null) {
                            // Remove lines
                            for (String deleteLine : methodRule.getDeleteLines()) {
                                body.getStatements().removeIf(s -> s.toString().contains(deleteLine));
                            }
                            // Add lines after a specific statement
                            for (String addLine : methodRule.getAddLines()) {
                                Statement newStatement = JavaParser.parseStatement(addLine);
                                if (methodRule.getAfterLine() != null) {
                                    for (Statement statement : body.getStatements()) {
                                        if (statement.toString().contains(methodRule.getAfterLine())) {
                                            body.addStatement(body.getStatements().indexOf(statement) + 1, newStatement);
                                        }
                                    }
                                } else {
                                    body.addStatement(newStatement);
                                }
                            }
                        }
                    }
                }
            });
        }
    }
}
```

### 4. **总结**

通过上述改进，框架现在可以根据文件名模式批量修改 Java 文件，包括：

1. **增加类上的注解**，并自动添加相应的 `import` 语句。
2. **替换或增加 `import` 语句**，支持替换旧的导入。
3. **修改方法体**，删除、增加特定行的代码，或移除整个方法。
4. **XML配置文件**提供了更精细的控制，可以针对不同的文件类型定义不同的修改规则。

使用这个框架，你可以根据实际需要扩展规则，从而实现对项目中大量 Java 文件的批量修改。

处理复杂的规则，如根据其他配置文件中的内容动态决定方法体的修改，确实需要更细致的策略。以下是如何实现这种功能的详细步骤：

### 1. **配置文件设计**

首先，你需要设计一个额外的配置文件，来定义这些动态内容。假设有一个配置文件 `methodContentConfig.xml`，用来描述方法体内的动态内容。

#### `methodContentConfig.xml` 示例

```xml
<methodContents>
    <method name="generateReport">
        <content>
            <add line="Report report = new Report();" />
            <add line="report.generate();"/>
        </content>
    </method>
    <method name="fetchData">
        <content>
            <add line="List<Data> data = new ArrayList<>();" />
            <add line="data.addAll(fetchFromDatabase());"/>
        </content>
    </method>
</methodContents>
```

### 2. **解析动态内容的配置**

扩展配置解析器以读取和解析这些动态内容配置。

#### `MethodContentConfigParser` 类

```java
import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class MethodContentConfigParser {

    public Map<String, MethodContent> parseMethodContents(String filePath) {
        Map<String, MethodContent> methodContents = new HashMap<>();
        try {
            File file = new File(filePath);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(file);

            doc.getDocumentElement().normalize();

            NodeList methodList = doc.getElementsByTagName("method");

            for (int i = 0; i < methodList.getLength(); i++) {
                Node node = methodList.item(i);
                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    Element element = (Element) node;
                    String methodName = element.getAttribute("name");
                    MethodContent methodContent = new MethodContent();

                    NodeList contentList = element.getElementsByTagName("content").item(0).getChildNodes();
                    for (int j = 0; j < contentList.getLength(); j++) {
                        Node contentNode = contentList.item(j);
                        if (contentNode.getNodeType() == Node.ELEMENT_NODE) {
                            Element contentElement = (Element) contentNode;
                            if ("add".equals(contentElement.getTagName())) {
                                methodContent.addLine(contentElement.getAttribute("line"));
                            }
                        }
                    }

                    methodContents.put(methodName, methodContent);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return methodContents;
    }
}

class MethodContent {
    private List<String> lines = new ArrayList<>();

    public void addLine(String line) {
        this.lines.add(line);
    }

    public List<String> getLines() {
        return lines;
    }
}
```

### 3. **集成动态内容处理**

在 `JavaFileModifier` 类中集成动态内容的处理逻辑。你需要在修改方法体时，检查是否有动态内容配置，并根据配置内容进行修改。

#### 更新 `JavaFileModifier` 类

```java
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.Statement;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.util.List;
import java.util.Map;

public class JavaFileModifier {

    private Map<String, MethodContent> methodContentMap;

    public JavaFileModifier(Map<String, MethodContent> methodContentMap) {
        this.methodContentMap = methodContentMap;
    }

    public void modifyFiles(File file, List<Rule> rules) throws Exception {
        FileInputStream in = new FileInputStream(file);
        CompilationUnit cu = new JavaParser().parse(in).getResult().get();
        in.close();

        for (Rule rule : rules) {
            if (rule.getFilePattern() != null && file.getName().matches(rule.getFilePattern())) {
                // Apply class annotation and imports
                if (rule.getClassAnnotation() != null) {
                    modifyClass(cu, rule);
                }
                if (!rule.getImports().isEmpty()) {
                    modifyImports(cu, rule);
                }
                if (!rule.getMethods().isEmpty()) {
                    modifyMethods(cu, rule);
                }
            }
        }

        // Ensure all modifications are applied before writing to file
        try (FileWriter fileWriter = new FileWriter(file)) {
            fileWriter.write(cu.toString());
        }
    }

    private void modifyClass(CompilationUnit cu, Rule rule) {
        cu.findAll(ClassOrInterfaceDeclaration.class).forEach(c -> {
            if (rule.getClassAnnotation() != null) {
                c.addAnnotation(new MarkerAnnotationExpr(rule.getClassAnnotation()));
            }
        });
    }

    private void modifyImports(CompilationUnit cu, Rule rule) {
        for (String importPackage : rule.getImports()) {
            if (!cu.getImports().stream().anyMatch(i -> i.getNameAsString().equals(importPackage))) {
                cu.addImport(importPackage);
            }
        }
    }

    private void modifyMethods(CompilationUnit cu, Rule rule) {
        for (MethodRule methodRule : rule.getMethods()) {
            cu.findAll(MethodDeclaration.class).forEach(m -> {
                if (m.getNameAsString().equals(methodRule.getName())) {
                    if ("remove".equals(methodRule.getAction())) {
                        m.remove();
                    } else if ("modify".equals(methodRule.getAction())) {
                        BlockStmt body = m.getBody().orElse(null);
                        if (body != null) {
                            // Remove lines
                            for (String deleteLine : methodRule.getDeleteLines()) {
                                body.getStatements().removeIf(s -> s.toString().contains(deleteLine));
                            }
                            // Add lines based on dynamic content
                            MethodContent methodContent = methodContentMap.get(methodRule.getName());
                            if (methodContent != null) {
                                for (String addLine : methodContent.getLines()) {
                                    Statement newStatement = JavaParser.parseStatement(addLine);
                                    if (methodRule.getAfterLine() != null) {
                                        for (Statement statement : body.getStatements()) {
                                            if (statement.toString().contains(methodRule.getAfterLine())) {
                                                body.addStatement(body.getStatements().indexOf(statement) + 1, newStatement);
                                            }
                                        }
                                    } else {
                                        body.addStatement(newStatement);
                                    }
                                }
                            }
                            // Add lines from method rule
                            for (String addLine : methodRule.getAddLines()) {
                                Statement newStatement = JavaParser.parseStatement(addLine);
                                if (methodRule.getAfterLine() != null) {
                                    for (Statement statement : body.getStatements()) {
                                        if (statement.toString().contains(methodRule.getAfterLine())) {
                                            body.addStatement(body.getStatements().indexOf(statement) + 1, newStatement);
                                        }
                                    }
                                } else {
                                    body.addStatement(newStatement);
                                }
                            }
                        }
                    }
                }
            });
        }
    }
}
```

### 4. **集成到批处理流程**

确保在执行批处理之前加载动态内容配置，并将其传递给 `JavaFileModifier` 实例。

#### 更新 `BatchProcessor` 类

```java
import java.io.File;
import java.util.List;
import java.util.Map;

public class BatchProcessor {

    private List<Rule> rules;
    private Map<String, MethodContent> methodContentMap;

    public BatchProcessor(List<Rule> rules, Map<String, MethodContent> methodContentMap) {
        this.rules = rules;
        this.methodContentMap = methodContentMap;
    }

    public void processFiles(File root) {
        File[] files = root.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    processFiles(file); // Recursively process directories
                } else if (file.getName().endsWith(".java")) {
                    try {
                        new JavaFileModifier(methodContentMap).modifyFiles(file, rules);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

### 5. **总结**

- **配置文件**：使用额外的配置文件定义动态内容，根据方法名和内容定义需要添加的代码行。
- **解析动态内容**：扩展配置解析器，读取和解析动态内容配置。
- **方法体修改**：在 `JavaFileModifier` 中集成动态内容处理，根据配置动态修改方法体。
- **批处理**：在 `BatchProcessor` 中传递动态内容配置，确保每个文件的修改符合动态内容配置要求。

这样，你可以根据额外配置文件中的内容动态修改方法体，实现更复杂的代码修改逻辑。
